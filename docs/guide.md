# Linux基础 

### vim的基本使用

**vim xxx.cpp**  --------------------  进入vim编辑器并创建一个cpp文件

在vim编辑器里有三个最常用的模式 ：  正常模式、编辑模式、命令行模式

#### 正常模式

一开始使用**vim  xxx.cpp** 直接进入的就是正常模式，  在这个模式下可以使用[**上下左右]**按键来移动光标， 也可以删除文件中的内容，复制、粘贴、撤销等 都是在这个模式下进行的。

#### 编辑模式

按下 **i，I，o，O，a，A，r，R**等任意一个字母之后就会进入编辑模式， 也就是你可以在这个编辑器中写东西了， 一般用的最多的就是i， 因为i 是insert的首字母， 按下**Esc**键就会退出编辑模式回到正常模式。

#### 命令行模式

只要输入“**:**”  冒号就会进入命令行模式 也可以使用“**/**”也能进入命令行模式， 按下**Esc**键就会退出命令行模式，回到正常模式。

#### 常用的快捷键使用

- 拷贝当前行  **yy**， 拷贝5行， 就是  **5yy**，  这个是以光标所在的位置为第一行，往下4行， 是包括当前行的。

- 删除当前行  **dd**， 删除5行， 就是 **5dd**， 这个也是以光标的位置为第一行， 往下4行， 是包括当前行的。

- 粘贴  **p**。

- 撤销  **u**。

- 在文件中查找某个单词使用“**/**”进入命令行模式， 然后输入你要查找的单词或者 字母都是可以的，然后就是在文件中用一中颜色把你查找到的单词或字母显示出来，   按下  “**n**” 查找下一个单词。

**以上都是在正常模式下进行的**



显示编辑器的行号，先进入命令行模式使用“**:**”   之后 **set nu**,  取消行号  **set nonu**  这里的nu就是number

如果使用vim编辑器进入一个很长的文件， 我们就可以使用 [ **G** ] 进入文档的最末尾， [ **gg** ] 进入文档的首行。

如果要指定  跳到哪一行的话，  先输入**30**  再 按**Shift+g**  就会跳转到30行。 

如果要进入命令行， 基本都是在正常模式下进行的。

- **:wq**   w表示写入其实就是保存，q就是quit退出，  就是保存并退出
- **:q**  就是直接退出

- :w 只保存

- **:q!**  强制退出，不会保存

### 关机重启注销

- **shutdown -h(halt) now**     立即关机   h  --  halt  停止的意思  
- **shutdown -r(reboot) now**  立即重启       r  --   reboot  重启的意思

- **shutdown -h(halt) 1**   表示要过一分钟之后关机

也能直接使用  **halt** 关机、  **reboot**  直接重启。

以上的命令都是在底层调用了  **sync** 。

sync 把内存的数据同步到磁盘中， 防止数据的丢失， 但是我们要以防万一，  在关机重启之前都先使用  至少一次  **sync**  不存数据。

**logout** 注销用户， 在图形化界面是没有效果的，

### 用户的管理

Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的 用户， 都必须首先先系统管理者申请一个账号。

- **su - 用户名**   切换用户， 从权限高的用户切换到权限低的用户不用输入密码， 但是从权限低的用户切换到权限高的用户就要输入密码。
- **who am i**    查看当前的用户的信息。这个查看是查看第一次登入时候的用户， 就算是切换了用户 ， 查看的也还是 第一次登的那个用户。

- **useradd 用户名**    添加用户，  同时会在/home目录下 分配一个同用户名一样的文件夹， 表示的这个用户的家目录。

- **passwd 用户名**    设计密码， 也可以说是修改密码， 如果当前输入用户名是新建的用户名，那就是新建密码， 如果是之前就存在用户名的，那么就是修改密码。

- **userdel 用户名**  删除用户，但是会保存这个用户的家目录。

- **userdel -r(remove) 用户名**  删除用户同时也会把这个用户的家目录一并删掉。

- 我们使用**su - root**   可以切换到root用户  如果我们要退回到原来的用户， 就要使用  **logout**  ， 如果再使用一次  logout  就会退出系统了， 但这样也是在Xshell中能实现，如果在图形化界面就只是退出终端。


#### 用户组

类似于角色， 系统可以对有共性的用户  或 有相同权限的用户进行分配， 可以分配到同一个组里，进行统一管理。

- **groupadd 组名**     新增一个组

- **groupdel 组名**      删除一个组

  如果新增一个用户，但是没有指定分配到哪个组里， 系统会创建一个  名 和用户名相同的组， 然后把这个用户放到这个组里。也就是说每一个用户都会在一个组里， 可能是同一个组也可能是不同的组。

- 要先创建一个组，然后把用户，指定分配到哪个组里

  - groupadd  wudang   创建了一个武当的组
  - useradd -g(group) wudang zwj   把张无忌放在直接放在武当这个组里

- 把用户切换到另外一个组里去，  首先切换的那个组要存在， 如果那个组都不存在那肯定是不行

  - **groupadd mojiao**    创建一个新的组  名为魔教
  - **usermod -g mojiao zwj**    把zwj从武当切换到魔教的这个组里

- usermod -g 用户组 用户名     把一个用户切换到另一个用户组里

#### 用户和组相关文件

**/etc/passwd** 文件      用户的配置文件， 记录用户的各种信息

![image-20221213152216061](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20221213152216061.png)

- **每行的含义： 用户名： 口令：x:  用户标识号：uid  组标识号：gid  注释性描述： 主目录： 登入的Shell**
- 中间有两个   ::   那是因为没有写注释
- Shell 可以理解为是一个解释器，  比如你输入了一个**cd** 这个命令， 然后发送给Linux内核，   Linux内核时看不懂这个的， 要先经过shell解释器  解析完之后再又shell发送给Linux内核，  我们常用的shell  都是  bash shell。

**/etc/shadow 文件**      口令的配置文件

![image-20221213153542321](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20221213153542321.png)

- 每行的含义： 登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志

​	在  1 和 2 的位置上有一串字符， 这是因为  这两个用户是设置了密码的， 然而 zwj是没有设置密码的   所以就是！！ 这样的形式

**/etc/group 文件**      组的配置文件， 记录Linux包含的组的信息

![image-20221213153850153](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20221213153850153.png)

- 每行的含义： 组名： 口令： 组标识号： 组内用户列表

### 指定运行级别

运行级别有 [0~6] 

- 0： 关机
- 1： 单用户  [找回丢失的密码]
- 2： 多用户状态没有网络服务
- 3： 多用户状态有网络服务
- 4： 系统未使用保留给用户
- 5： 图形界面
- 6： 系统重启

最常用的是 级别3   和  级别5

**init [0~6]  设置运行级别**

如果设置了   **init 0   那么系统就会关机了**，   如果设置了  **init 6  那么系统就会重启**

**systemctl get-default    获取当前的运行级别**

**systemctl set-default xxxx**     修改默认的运行级别， 也就是下次开机的时候就是这个设置的运行级别了。

**multi-user.target**     相当于就是  3的运行级别

**graphical.target**     相当于就是   5的运行级别

### 找回root密码

1. 首先， 启动系统， 进入开机界面， 在界面中按  “e”  进入编辑界面
2. 进入编辑界面，使用键盘上的上下键把光标往下移动，找到以  “Linux16” 开头内容所在的行数， 在行的最后面输入: **init=/bin/sh**
3. 接着，输入完成之后，直接按快捷键： Ctrl+x  进入单用户模式
4. 接着，在光标闪烁的位置中输入： mount -o remount,rw /     完成之后就按回车键
5. 在新的一行最后面输入： passwd      按回车键        之后就输入密码了，  然后再次确认密码，  如果显示了passwd........的样式， 就说明成功了
6. 接着，在鼠标闪烁的位置中 输入： touch /.autorelabel     按回车键
7. 继续在闪烁的位置中输入：   exec /sbin/init      按回车键     等待系统自动修改密码， 完成后，系统会自动重启，新的密码生效


### 帮助指令

**man 命令**      获取该命令的帮助信息

**命令 --help**    获取该命令的内置信息

当然，这样两者显示的都是英文的， 我们也能通过修改终端的编码-------------------------------------

通过这篇博客应该是没问题的了吧。

### 文件目录类

- **pwd**     显示当前工作目录的**绝对路径**
  
  - 绝对路径：  可以理解为从根目录一直找， 直到找到要的文件为止 。
  - 相对路径：  可以理解为从当前的开始找，直到找到要的文件为止。
  
- **ls**   **[选项]** [目录或文件]

  - **ls -a(all)**      显示当前目录所有文件和目录， 包含隐藏文件
  - **ls -l(list)**       以列表的方式显示信息

- **cd [参数]**     切换到指定的目录，可以是绝对路径，也能是相对路径

  - **cd ~  或者 cd :**       回到自己的家目录
  - **cd ..**        回到当前目录的上一级目录

- **mkdir [选项]**   要创建的目录

  - **mkdir  目录名**         这样就只能创建一级目录
  - **mkdir -p(parents)**     这样就可以创建多级目录，  什么叫多级目录，比如  /home/pan/ni/hao    ,  在家目录下是没有ni  也没有hao， 这样创建就叫做创建多级目录

- **rmdir**     删除空目录，  如果要删除的那个目录下有内容则无法删除

- **rm -rf**     删除非空目录，  其实就是相当于强制删除 force

- **touch 文件名**       创建一个空的文件

- cp   拷贝文件到指定文件夹

  - **cp 文件名   指定的文件夹**
  - **cp -r**(**force)**     要拷贝的文件    指定的文件夹         这个就是把整个文件拷贝到另一个文件夹
  - **\cp -r(force)**  要拷贝的文件夹   指定的文件夹       这样表示强制覆盖

- **rm -r(recursive)  文件夹名**        递归删除整个文件夹

- **rm -f(force)   文件**         强制删除某个文件

- **rm -rf** **文件或文件夹**    强制递归删除整个文件夹

- **rm  文件**     单纯的删除某个文件

- mv  移动文件与目录或重命名

  - **mv 旧的文件名  新的文件名**         表示重命名
  - **mv   旧的文件位置   新的文件位置**           表示移动位置
  - **mv 旧的文件位置   新的文件位置/aa.txt**     表示移动位置并重命名

- **cat 文件名**       表示查看该文件里面的内容

- **cat -n(number) 文件名**      表示查看该文件里面的内容并显示行号

- **cat -n(number) 文件名 | more**   和上面一样只不过不会一下就显示出来是按页数来显示也就是说和滚动的，   这里的   |  more  表示管道命令， 就是把前面得到的结果给后面的命令

- **less 文件**        用来分屏查看文件内容， 功能和more指令类似， 但是比more指令更加强大， 支持各种显示终端，是根据显示需要加载内容而加载

  - 空格         向下翻动一页
  - [pagedown]     向下翻动一页
  - [pageup]      向上翻动一页
  - /字符      向下查找字符的功能   n   向下查找   N  向上查找
  - ？字符    向上查找字符的功能   
  - q  离开less功能
  
- **echo 内容**           把后面的内容输出在控制台中，   例如： $PATH,   输出环境变量 ，  $HOSTNAME   输出主机名。其实可以把这个理解为c语言中的printf   可以经行格式化。  更多的可以  **help echo** 查找

- **head 文件**         用于显示文件的开头部分内容，  默认情况下head显示文件的前10行内容

- **head -n(number) 8 文件**         表示显示前8行，  后面的数字的可以随意的

- **tail 文件**            用于输出文件尾部的内容， 默认显示文件最后10行

- **tail -n(number) 8 文件**       表示显示文件最后8行， 后面的数字是可以改变的

- **tail -f(follow)  文件**    实时的监控该文件的变化，  你在xshell中监控  如果在你Linux主机上改变， 那么在xshell中就能立马知道改变了些什么

-    **">"    这个小于号的指令**           表示输出重定向，   比如  echo “hello”   本来这个hello是要输出在终端上的， 但是如果你加了  echo “hello” > hello.txt     那么就表示  把这个hello 重定向写入了 hello.txt 文件了。  这个就是重定向， 意思很明显，就是把本来要输出的，不输出写进另一个地方，  但是会把原来文件中有的内容先删除， 然后在写入， 就是覆盖的意思。

- **“>>”   两个小于号的指令**    表示追加，   大致和 “>”  这个一样， 但是不会把原来文件里面的内容删掉， 只是在末尾追加你写入的内容

- **ln -s 原文件或目录  软链接名**        就是给原文件或目录创建一个软链接，  就是有点像windows里桌面上的图标，这个图标其实就是一个软链接， 指向了原文件的地址，  也就是以后只要进入这个软链接其实就是进入了原来的那个地址里了

  ​	![image-20221222132421640](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20221222132421640.png)

​		 这个就是软链接，  如果你进入了myjs这个文件夹中 就相当于进入了./js/这个目录里了

- **history**             显示你曾经一共用了多少条命令， 都会一一显示出来，显示的是全部
- **history 10**         表示显示最近使用的10命令，  这个数字是可以改变的
- **!5**         表示执行历史编号为5的命令

### 时间日期类

- **date**     显示当前的时间
- **date +%Y**       显示当前的年份
- **date +%m**       显示当前的月份
- **date +%d**     显示当前的日期
- **date “+%Y-%m-%d %H:%M:%S”**        显示当前的年月日时分秒
- **date -s(set)  字符串时间**        设置当前的时间   比如 2022-11-02 20：56：12
- **cal**      查看日历
- **cal 年份**          显示的这一整年的日历

### 搜索查找类

- **find 指令**  将从指定目录向下递归的遍历其各个子目录，  将满足条件的文件或者目录显示在终端
- **find [搜索范围] [选项]**
  - 选项    **-name**         按照指定文件名查找
  - 选项   **-user**           查找属于指定用户名所有文件
  - 选项   **-size       +n 大于      -n小于     n等于**          按照指定的文件大小查找文件
- **find /home/ -name he.txt**       显示命令   之后是范围    之后就是选项    具体的名字
- **find / -size +200M**           表示从根目录开始查找，大于200M的文件
- **locate 指令**        可以快速定位文件路径， 会自己创建一个数据库， 然后这里面快速查找， 要使用**locate命令**     就要先使用一次  **updatedb**    再使用  **locate**  才能查找成功，   不然就算有也不能查找成功
- **which**      用来查找那个命令在那个文件夹中存放   比如    **which ls**     就是用来查找ls存放在哪个文件夹中
- **grep命令**        是用来过滤查找的，  通常和    |    一起使用 
  - 选项    -n    显示行内容及行号
  - 选项   -i     忽略字母大小写
- **cat he.txt | grep -n "hello"**        表示查看he.txt内容里面的   具有hello的行及行号   
- **grep -n “yes” /home/pan/c++/he.txt**       表示查找he.txt 文件里的 含有  yes的内容及行号

### 压缩和解压类

- **gzip 文件名**           压缩文件把文件压缩成 *.gz文件
- **gunzip  文件.gz**             解压.gz文件
- **zip -r  xx.zip /home/pan/c++**                 意思就是把/home/pan/c++ 这个路径的c++文件夹进行压缩成  xx.zip压缩包
- **unzip -d /home/pan/cpp xx.zip**         意思是说把xx.zip  解压到指定的文件夹中
- **tar [选项] xxx.tar.gz 打包的内容**   是打包指令   最后打包成的文件是  .tar.gz 的文件
  - -c       产生  .tar 打包文件
  - -v      显示详细信息
  - -f       指定压缩后的文件名
  - -z      打包同时压缩
  - -x     解包.tar 文件
    - **tar -zcvf xx.tar.gz /home/pan/pig.txt /home/pan/g.txt**      意思是把两个文件 同时压缩，压缩之后的名字是xx.tar.gz
    - **tar -zxvf xx.tar.gz -C /home**     意思是把xx.tar.gz 包解压 -C 就是 同时解压到哪个目录中

### 组管理和权限管理

在Linux中的每个用户必须属于一个组，不能独立于组外。在Linux中每个文件有所在者、所在组、其他组的概念。

#### 组管理

对一个文件而言，  有三个概念 ：

1. 所有者：   就是创建文件的用户，  当然这个所有者也是能改变， 就像你买了东西之后你还可以转让。

2. 所在组：  创建文件用户所在的组

3. 其他组：  其他用户所在的组， 不是创建该文件的其他用户所在的组， 其他组也是能管理这个文件，但是就要利用权限的概念了。

- **ls -ahl**           查看文件的所有者
- ![image-20221225174628905](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20221225174628905.png)

​							这个就是所有者

- **chown 用户名 文件名**                  修改文件的所有者
- **chgrp 组名 文件名**               修改文件的所在组
- **chown -R 新的用户名  文件名**        把这个文件的所有者修改为新的用户，-R   表示把这个目录下的所有文件目录都是修改成这个新的用户，也就是递归修改
- **chgrp -R 新组名 文件名**          把这个文件的所在组修改为新的组，-R  表示递归修改该目录下的所有文件目录的组。
- root用户可以改变其他用户所在的组
  - **usermod -g 新组名 用户名**             把这个用户更改至这个新的组里面
  - **usermod -d 新目录  用户名**          改变用户登录的初始目录        特别说明： 用户需要有进入到新目录的权限


#### 权限管理

使用**ls -l**  会显示下面的图

![image-20221226122740063](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20221226122740063.png)

都会显示前面这样的字符， 首先这样的字符不管是文件还是目录等都是有10个组成，这10个分成了四个部分

- 第一部分(0位)
  - **第零位确定文件的类型(d, -, l, c, b)**
    - **l**    是链接      就是使用**ln -s**  创建了软链接，相当于Windows里的快捷方式
    - **“-”**   就是一个不同的文件
    - **b**    是块设备   比如 硬盘
    - **d**   是目录   相当于windows里的文件夹
    - **c**  是字符设备文件   比如 鼠标、键盘
- 第二部分(1-3位)
  - 表示确定所有者(该文件的所有者)拥有该文件的权限。 ---- User
  - **rwx作用到文件上**
    - **r（read）**  可以读取，查看文件
    - **w（write）**   可以修改文件，但是不代表可以删除文件，要删除一个文件的前提是对该文件所在的目录有写权限，才能删除
    - **x（execute）**   该文件可以被执行，当然这个文件得是可执行文件，才能。
  - **rwx作用到目录上**
    - **r（read）**   可以读取，也就是  **ls** 命令能执行， 查看目录里有什么文件
    - **w（write）**     可以修改    对目录内创建+删除+重命名目录，只是对目录而言，里面的文件还是要看文件的权限和目录的权限没有关系，如果你是要修改一个文件的话，那你必须要有文件的w权限，并不是目录的w权限
    - **x（execute）**       可以进入目录  也就是能执行   **cd**命令
  - 同样 **也可以用数字表示   r=4, w=2, x=1   rwx=4+2+1 = 7**
- 第三部分(4-6位)
  - 确定所属组(同用户组的其他用户)        拥有该文件的权限。  ---- Group
- 第四部分(7-9位)
  - 确定其他用户，也就是其他组的用户了    对该文件操作的权限。 ---- Other
- chmod 命令    表示可以修改文件或目录的权限
  - u：所有者              g: 所在组                o: 其他组      a：所有人(u, g, o的总和)
  - **chmod u=rwx,g=rx,o=x 文件/目录名**         表示修改所有者，所有组，其他组赋予相应的权限
  - **chmod o+w 文件/目录名**            表示把其他组都赋予可写的权限
  - **chmod a-x 文件/目录名**       表示把所有人的可执行权限都去掉

### 定时任务调度

  #### crond任务调度

任务调度： 是指系统在某个时间执行的特定的命令或程序。

任务调度分类：

- 系统工作： 有些重要的工作必须周而复始地进行。如病毒扫描等。
- 个别用户工作：个别用户可能希望执行某些程序，比如 对mysql数据库的备份

**crontab**  [选项]

- -e         编辑crontab定时任务
- -l           查询crontab任务
- -r           删除当前用户所有的crontab任务

首先使用 **crontab -e**  进入编辑区， 然后再编辑区中输入你想要定时执行的任务。

比如 ***/1 ls -l /etc/ > /tmp/to.txt**   命令      这里表示先查询/etc中的文件， 然后重定向到/tmp下的to.txt文件中如果没有就会创建

每隔一分钟就会执行这个命令

五个占位符的说明

| 项目       | 含义                   | 范围                    |
| ---------- | ---------------------- | ----------------------- |
| 第一个 “*” | 一个小时当中的第几分钟 | 0-59                    |
| 第二个“*”  | 一天当中的第几个小时   | 0-23                    |
| 第三个”*“  | 一个月当中的第几天     | 1-31                    |
| 第四个”*“  | 一年当中的第几个月     | 1-12                    |
| 第五个”*“  | 一周当中的星期几       | 0-7(0和7都是代表星期日) |

特殊符号的说明

| 特殊符号 | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| *        | 代表任何时间。比如第一个”*“ 就代表一小时中每分钟执行一次的意思。 |
| ,        | 代表不连续的时间。比如”0 8,12,16 * * *命令“， 就代表在每天的8点0分，12点0分，16点0分都执行一次命令 |
| -        | 代表连续的时间范围。比如”0 5 * * 1-6 命令“ ，代表再周一到周六的凌晨5点0分执行命令 |
| */n      | 代表每隔多久就执行一次。比如”/10 * * * * 命令“，代表每个10分钟就执行一遍命令 |

- **service crond restart**     重新启动任务调度服务

#### at定时任务

at命令是一次性定时任务，at的守护进程atd会 以 后台模式运行，检查作业队列来运行。

默认情况下，atd守护进程**每60秒**检查作业队列，有作业的，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业。

at命令是一次性定时计划任务，执行完一个任务后不再执行此任务了。   **作业队列其实就是任务队列**

再使用at命令的时候，一**定要保证atd进程的启动**，可以使用相关指令来查看。

- **ps -ef**     查看当前有哪些进程
- **ps -ef | grep atd**      因为进程会有很多所以要使用过滤， 只选择atd的就行了
- **systemctl start atd**    启动atd进程  
- ![](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20221230163500460.png)

如果出现这个就说明没有**atd.service**  那么就要使用 **sudo apt install at**   下载 

之后就能查看atd进程了 

**at [选项] [时间] **

**Ctrl + D  结束at命令的输入**  而且要输入两次 

**atq**  查看系统有没有at定时任务

### Linux分区

#### 分区的概念

1. Linux来说无论有几个分区，分给哪个目录使用， **归根结底就只有一个根目录**， 一个独立且唯一的文件结构，Linux中每个分区都是用来组成整个文件系统的一部分。

2. Linux采用了一中叫“载入” 的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来， 这时要载入的一个分区将使它的存储空间在一个目录下获得。

   ![image-20221231161400296](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20221231161400296.png)

这个图大概就是硬盘和文件对应的关系了， 就是一个分区挂载到一个目录上，如果要增加硬盘也是一样， 也是把这个新的硬盘的分区挂载到Linux的目录上。

- **lsblk**   或者  **lsblk -f**   这个命令可以查看该系统上  硬盘分区和目录对应的关系

#### 硬盘说明

1. Linux硬盘分**IDE硬盘**和**SCSI硬盘**， 目前基本上都是SCSI硬盘了。
2. 对于 **IDE硬盘**， 驱动器标识符为：  **“hdx~”**， 其中 “hd” 表示分区所在设备的类型， 这里就是IDE硬盘， “x” 表示盘号(a为基本盘，b为基本从属盘， c为辅助主盘， d为辅助从属盘)， “~” 代表分区， 前四个分区用1-4表示，它是主分区或扩展分区，第5个开始就是逻辑分区，比如 hda3, 就表示第一个IDE硬盘上的第三个主分区或扩展分区。
3. 对于SCSI硬盘也是一样的， 就是  类型用  “sd” 表示， 后面都是一样的
4. ![image-20221231163219748](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20221231163219748.png)

![image-20221231163229375](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20221231163229375.png)

#### 增加硬盘

在虚拟机的设置里，有一个添加， 然后点击添加， 就可以设置添加一块多大的硬盘了，这样也就只是孤零零的一块硬盘，并没有分区

- **fdisk /dev/sdb**     开始对sdb进行分区，  /dev 这个目录里面装的都是设备文件， 所以硬盘也当然在这里面了
- 使用上面的命令回车之后就会出现
  - ![image-20230101140808362](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20230101140808362.png)



之后按下**m**后就会出现

![image-20230101140850393](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20230101140850393.png)

那么此时我们就按下  **n**  就行了

![image-20230101141116551](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20230101141116551.png)

现在有了分区但是还是不能立马挂载到目录上，还要进过格式化， 只有经过格式化之后才会给这个分区分配一个唯一的标识符

- **mkfs -t(type) ext4 /dev/sdb1**    格式化硬盘，   ext4  是分区的类型
- **mount /dev/sdb1 /newdisk**     表示把创建的分区挂载到 /newdisk目录上，   **用命令行挂载重启之后会失效**

> 永久挂载：  通过修改 **/etc/fstab** 实现挂载
>
> ![image-20230101143232693](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20230101143232693.png)
>
> 要添加这么个数据就行， 肯定是要保存的
>
> 添加完之后执行  mount -a  即刻生效

- **umount /dev/sdb1**   或 **umount /newdisk**      取消分区和目录的连接

#### 磁盘情况查询

查询系统整体磁盘使用情况

- **df(disk free) -h(human)**       查询系统磁盘整体情况,  -h  也就是按人的方式看，也就是说大小是按M，G等， 而不是KB了

查询指定目录的磁盘占用情况

- **du -h /目录**        查询指定目录磁盘占用情况

  > -s  指定目录占用大小汇总
  >
  > -h 带计量单位
  >
  > -a 含文件
  >
  > --max-depth=1 子目录深度



1. 统计 /opt 文件夹下文件的个数

   > **ls -l /opt | grep "^-" | wc -l**             "^"  表示以什么什么开头

2. 统计/opt文件夹下目录的个数

   > **ls -l /opt| grep "^d" | wc -l**                  "^"  表示以什么什么开头

1. 统计/opt文件夹下文件的个数，包括子文件夹里的

   > **ls -Rl | grep "^-" | wc -l**                    -R   表示递归显示子文件夹里的

2. 统计/opt文件夹下目录的个数，包括子文件夹里的

   > **ls -Rl | grep "^d" | wc -l**                    -R   表示递归显示子文件夹里的

3. 以树状显示目录结构

   > **tree /opt**                  如果没有tree命令， 则就下载该命令， 一般终端会有提示的

### Linux网络配置

ip地址必须要在同一个网段才能通信， 也就是前面三个数必须一样比如**192.168.2**.xxx   这三个必须要一样

- **ping 目的主机的IP地址**            测试主机之间的网络联通性
- ping  www.baidu.com       测试当前主机是否可以连接百度

指定ip

- **vim /etc/sysconfig/newwork-scripts/ifcfg-ens33**   进入这个配置里

- 将ip地址的配置成静态的

  > DEVICE=eth0       接口名(设备，网卡)
  >
  > HWADDR=00:0C:2x:6x:0x:xx   MAC地址
  >
  > TYPE=Ethernet       网络类型
  >
  > UUID=323ff3r-faf323-faw3-xxx    随机的id
  >
  > ONBOOT=yes        系统启动的时候网络接口是否有效
  >
  > BOOTPROTO=static     设置成静态的
  >
  > IPADDR=192.168.200.130   设置ip地址
  >
  > GATEWAY=192.168.200.2    设置网关
  >
  > DNS1=192.168.200.2    设置域名解析器

设置完了之后 要重启系统或重启网络服务

**service network restart**     重启网络服务

#### 设置主机名和hosts映射

ping的时候通常都是使用ip地址，但是ip地址通常不太好记，所以我们就使用主机名

- **hostname **      查看主机名
- **vim /etc/hostname**       在这里修改主机名，之后就重启
- 如果是在windows中ping的话， 那么就要在c:\Windows\System32\driver\etc\hosts  文件指定ip和主机名的关系
- 如果在Linux中ping的话， 那么就要在/etc/hosts 文件指定
- 都是先写  ip地址    后面写主机名

Hosts是什么

- 一个文本文件，用来记录IP和Hostname的映射关系

DNS是什么

- DNS，就是DOmain Name System的缩写， 就是域名系统

- 是互联网上作为域名和IP地址相互映射的一个分布式数据库

- **ipconfig /displaydns**         DNS域名缓存， 也就之前访问的地址都会缓存起来

- **ipconfig /flushdns**      手动清理dns缓存

  > 用户输入在浏览器的地址栏中输入了一个网址， 先是在浏览器的缓存中找，看看有没有， 如果没有， 就在本地系统的DNS缓存中找，如果还没有找到，就到本地的hosts文本文件中找， 如果还是没有找到， 就到互联网中的DNS缓存查找， 如果还是没有找，就说明这个域名不存在， 但是一旦找到会就返回，给浏览器经行访问。

### 进程

1.  Linux中，每个执行的程序都是称为一个进程。每个进程都分配一个ID好（pid，进程号）。
2.  每个进程都可能一两种方式存在。 前台和后台，所谓的**前台进程就是用户目前屏幕上可以进行操作的**，**后台进程则是实际在操作的**，但是由于屏幕上无法看到的进程，通常使用后台方式执行。
3. 一般系统的服务都是以后台进程的方式存在， 而且都会常驻在系统中。直到关机从结束

- **ps**   先是当前的进程信息
- **ps -a**         显示当前终端的所有进程信息
- **ps -u**         以用户的格式显示进程信息
- **ps -x**         显示后台进程运行的参数
- 如果不想要这么多进程， 我们可以根据需要进行过滤  | grep  xxx

![image-20230101174034062](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20230101174034062.png)

> USER:    使用该进程的用户
>
> PID：    进程号
>
> %CPU：    进程占用cpu的百分比
>
> %MEM：    进程占用物理内存的百分比
>
> VSZ：    进程占用的虚拟内存的大小  单位：kb
>
> RSS：   进程占用的物理内存大小  单位： kb
>
> TTY ：  终端名称，缩写
>
> STAT：   进程状态， S-睡眠 ,s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程， T-被跟踪或被停止等等
>
> START：  进程的启动时间
>
> TIME：  cpu的时间， 进程使用cpu的总时间
>
> COMMAND：  启动进程所用的命令和参数，如果过长会被截断显示

**ps -ef**      以全格的形式显示当前所有的进程

一个进程又创建了多个进程那这个进程被称为父进程

#### 终止进程kill和killall

如果某个进程执行到一半需要停止时，或是已消耗了很大的系统资源时，此时可以考虑停止该进程，使用kill就能停止进程

- **kill 进程号**         通过进程号，杀死进程或叫做终止进程
- **killall 进程号**         也是通过进程号，终止进程，这个终止进程终止该进程以及子进程
- **kill -9 进程号**         通过进程号，强制终止进程， 这是因为可能，该进程正在运行，可能终止不掉，所以就要 使用**-9**强制终止
- 想要终止进程，首先就要同  ps -aux | grep xxx      过滤掉 直接查看你想要终止的进程
- 如果你把sshd进程终止掉了， 那么，就不能远程登入Linux了，sshd是管理远程的， bash是本机上的终端

#### 查看进程树

- **pstree [选项]**      可以更加直观的来看进程信息
- **-p  ：**   显示进程的PID， 也就是进程号， PPID是父进程号
- **-u：** 显示进程的所属用户
- ![image-20230102150326576](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20230102150326576.png)

进程树就是这样的。

### 服务(service)管理

服务：**本质就是进程**，但是是运行在后台的，通常hi监听某个端口，等待其他程序的请求，比如(mysqld, sshd, 防火墙)，因此我们也称之为**守护进程**。

![image-20230102151117226](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20230102151117226.png)

service管理指令

- **service 服务名 [start(启动) | stop(停止) | restart(重启) | reload(重载) | status(状态)]**
- **service 服务名 start**        启动某个服务
- **service 服务名 stop**       停止某个服务
- **service 服务名 restart**      重启某个服务
- **service 服务名 reload**     重在某个服务
- **service 服务名 status**      查看某个服务的状态

在CentOS7.0后，**很多服务不在使用service**，**而是使用 systemctl**

如果要查看还有那些服务还是可以用service的，那么可以使用  

- **ls /etc/init.d**         查看这个配置文件,   绿色的都是， 因为我这里使用的Ubuntu系统， 如果使用的CentOS的系统就很明显了

![image-20230102152054502](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20230102152054502.png)



如果你使用  **service network stop**  ， 也就是停止了， 网络的服务，这样， 就是直接断开了，客户端与端口的连线了， 也就是不能，连接了， 但是你使用start可以开启服务，这样又能重新连接了。

在Ubuntu中使用

- **sudo systemctl list-unit-files**   可以查看系统所有的服务

Linux开机的流程：

> 开机   ==>>   BIOS   ==>>    /boot    ==>>   system进程(所有进程的祖宗)  ==>>   运行级别     ==>>  运行级别对应的服务



在CentOS中

> 通过**chkconfig**  可以给服务的各个运行级别设置  自启动还是自关闭
>
> **chkconfig --list**       查看服务的列表， 在每个运行级别下的方式
>
> **chkconfig 服务名  --list**     显示该服务的列表
>
> **chkconfig --level x(0-6) 服务名 on/off**       把某个服务在哪个运行级别设置成什么方式

-  **ls -l /usr/lib/systemd/system**       查看systemctl  管理的服务

  > systemctl start 服务名              启动某个服务
  >
  > systemctl restart 服务名       重启某个服务
  >
  > systemctl stop 服务名       停止某个服务
  >
  > systemctl  status 服务名      查看某个服务的状态

- **systemctl list-unit-files**      查看服务开机启动状态 ，当然可以使用 grep 进行过滤

- **systemctl enable 服务名**      设置服务开机启动

- **systemctl disable 服务名**     关闭服务开机启动

- **systemctl is-enabled 服务名**      查询某个服务是否是自启动

  - **enabled**      是自启动的状态（开机就启动）
  - **disabled**      自关闭的状态（开机不会启动，要手动启动）

查看防火墙当前的状态

- **ls -l /usr/lib/systemd/system | grep firewalld**

这里就解释下什么是**防火墙**，  防火墙，可以理解为是在服务的端口前加了一堵墙， 这个墙可以防止外来的程序，访问该系统的服务，对服务的端口有监听的效果， 比如就是  sshd服务， 端口号是22， 如果我们打开了防火墙， 我们远程连接就不一定有用， 就是因为防火墙隔绝了，外来的连接， 但是还是有可能连接的， 就是虽然打开了防火墙，但是同样，这个端口号在防火墙中依然打开，这样也是能连接的 ， 大概就是下图的意思， 就是端口前面还会有一层防护。

![image-20230102170542504](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20230102170542504.png)

- **netstat -anp | more**      查看网络的状态   这里面就能看见什么端口打开了还是没打开，也能查看是什么协议的
- **firewall-cmd --permanent --add-port=端口号/协议**        在防火墙里打开一个端口
- **firewall-cmd --permanent --remove-port=端口号/协议**         在防火墙里关闭一个端口
- 重新载入，才能生效： **firewall-cmd --reload**
- **firewall-cmd --permanent --query-port=端口号/协议**     查询某个端口号是否开放

#### 动态监控进程

**top指令**和**ps指令**很相似，都是用来显示正在执行的进程， 但是top最大的不同之处在于，top在执行一段时间可以更新正在运行的进程

- top [选项]
  - -d 秒数                  指定top命令每个几秒更新，默认是3秒
  - -i            使top不显示任何闲置或僵死的进程
  - -p      通过指定监控进程ID来仅仅监控某个进程的状态

![image-20230102175152441](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20230102175152441.png)

上图显示了动态监控的描述

交互操作

| 操作 | 功能                                  |
| ---- | ------------------------------------- |
| P    | 以CPU使用率排序，默认也是使用这个排序 |
| M    | 以内存的使用率排序                    |
| N    | 以PID排序                             |
| q    | 退出top                               |

监控某个用户， **就是先进入 top 之后再按下  u**，  **然后就是输入， 你想要监控的用户的用户名了**

终止指定的进程**，先进入 top 之后再按下  k 回车，  然后就是输入 进程号**

#### 监控网络状态

- **netstat [选项]**
  - **-an**   按一定的顺序排列输出
  - **-p**     显示哪个进程在调用
- ![image-20230102200708563](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20230102200708563.png)
- **ping 地址**        检测主机连接命令， 后面带上地址



### 日志管理

系统常用的日志文件  保存在   **/var/log**     目录下

| 日志文件             | 说明                                                         |
| -------------------- | ------------------------------------------------------------ |
| `/var/log/boot.log`  | **系统启动日志**                                             |
| `/var/log/cron`      | **记录与系统定时任务相关的日志**                             |
| /var/log/cups/       | 记录打印信息的日志                                           |
| /var/log/dmesg       | 记录了系统在开机时内核自检的信总。也可以使用dmesg命令直接查看内核自检信息 |
| /var/log/btmp        | 记录错误登录的日志信息， 这个文件是二进制文件，不能直接用Vi查看，而要使用**lastb****命令**查看 |
| **/var/log/lastlog** | **记录系统中所有用户最后一次的登录时间的日志。这个文件也是二进制文件。要使用lastlog命令查看** |
| **/var/log/mailog**  | **记录邮箱信息的日志**                                       |
| **/var/log/message** | **记录系统重要消息的日志。这个日志文件中会记录Linux系统绝大多数重要信息，如果系统出现问题，首先要检查的应该就是这个日志文件** |
| **/var/log/secure**  | **记录验证和授权方面的信息，只要涉及账户和密码的程序都会记录，比如系统的登录，ssh的登录，su切换用户，sudo 授权，甚至添加用户和修改用户和修改用户密码都会记录在这个日志文件中** |
| /var/log/wtmp        | 永久记录所有用户的登录，注销信息，同时记录系统的后台，重启，关机事件。是二进制文件，而要使用last命令查看 |
| **/var/tun/ulmp**    | **记录当前已经登录的用户的信息。这个文件会随着用户的登录和注销而不断变化，只记录当前登录用户的信息。这个文件不能用Vi查看，而要使用w， who， users等命令查看** |

#### 日志管理服务

**ps -aux | grep "rsyslogd" | grep -v "grep"**      查看进程中这个日志服务有没有在运行， **grep -v 表示反向过滤，**

如果在一个文件中有a, b, c 三个选项， 如果我们是 grep a, 那么挑选的就是a， 如果是 grep -v a  那么就是选择b，和c

配置文件：

- **/etc/rsyslog.conf**

  >编辑文件时的格式：  * . *    存放日志
  >
  >其中第一个 * 代表日志的类型， 第二个 * 代表日志的级别
  >
  >1. 日志的类型分为：
  >
  >   1. auth                     pam产生的日志
  >   2. **authpriv             ssh、ftp等登录信息的验证信息**
  >   3. **corn                     时间任务相关**
  >   4. kern                       内核
  >   5. lpr                            打印
  >   6. mail                         邮件
  >   7. mark(syslog)-rsyslog                       服务内部的信息，时间标识
  >   8. news                  新闻组
  >   9. **user                 用户程序产生的相关信息**
  >   10. uucp                    unix to nuix copy主机之间的相关通信
  >   11. local 1-7                   自定义的日志设备
  >
  >2. 日志级别
  >
  >   1. debug                    有调试信息的，日志通信最多
  >   2. info                       一般信息日志，最常用
  >   3. notice                   最具有重要信息的普通条件的信息
  >   4. warning                警告级别
  >   5. err                       错误级别， 阻止某个功能或模块不能正常工作的信息
  >   6. crit                       严重级别，阻止整个系统或者整个软件不能正常工作的信息
  >   7. alert                      需要立即修改的信息
  >   8. emerg                   内核崩溃等重要信息
  >   9. none                    什么都部记录
  >
  >   从上到下，级别从低到高，记录信息越来越少

#### 日志轮替

日志轮替就是把旧的日志文件移动并改名，同时建立新的空白日志文件，当旧的日志文件超出保存范围之后就会进行删除





# Shell编程

shell是一个命令解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统程序，用户可以用shell来启动，挂起，停止甚至是编写一些程序。

- 脚本格式
  - 脚本以    **#!/bin/bash**    开头
  - ![image-20230104121056378](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20230104121056378.png)
  - 脚本需要有可执行权限， 因为创建的文件一开始是没有执行权限的， 所以要先赋一个执行权限才能运行，相对路径，绝对路径都行。
  - 如果没有执行权限       **sh 脚本名.sh**     这样即使没有权限也是能执行的
  - ![image-20230104121117300](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20230104121117300.png)

### Shell变量

1. Linux Shell中的变量分为， **系统变量**和**用户自定义变量**
2. 系统变量： $HOME, $PWD, $SHELL, $USER等等，  用  echo $PWD, 就能输出当前的位置在哪
3. 显示所有的系统变量：    **set**

![image-20230104135307804](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20230104135307804.png)

在Shell编程里， **等号两边是不能有空格的**， 在其他语言里是允许的，但是这里是不允许的，还有就是，**变量名称一般习惯为大写**

当然小写也是可以的，但是用大写是规范

- 将指令返回的结果赋值给一个变量
- A=`date`或则A=$(date)， 这两种形式都是可以的。
- ![image-20230104140321135](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20230104140321135.png)

输出的结果， 就是把用date命令查询到的时间， 作为结果返回同时赋值给A这个变量

​	![image-20230104140346555](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20230104140346555.png)

### 设置环境变量

1. **export 变量名=变量值**         (将shell变量输出为环境变量/全局变量)
2. **source 配置文件**                （让修改后的配置信息立即生效）
3. **echo $变量名**                    （查询环境变量的值）

如果要设置环境变量就要在    **/etc/profile**    文件里添加一些信息，有点像Windows的path里的变量一样，都是环境变量

在shell编程里   单行注释是  “#”，   多行注释是   “  :<<! 中间写内容!  ”



### 位置参数变量

这个位置参数变量有点像c语言中的，实参和形参。

一般是这么写    ：      **./mysh.sh 100 200**      这里的100， 和200， 有点像实参，   表示第一个参数，第二个参数，第零个参数就是./mysh.sh。

在这个脚本里面拿到这个参数，就有点像 形参了。

- **$n** （n位数字，$0表示命令本身， **$1-$9,表示从1到9个参数**，10以上就要用**${10}**, 大括号表示了）
- **$***    (表示获取到了，命令行中的所有参数，  是把所有参数看成一个整体， 就有点像，看成了一个字符串了)
- **$@**    (这个也是获取命令行中的所有参数， 但是这个不是把参数看成一个整体，而是分开的)
- **$#**      (获取命令行中所有参数的个数)
- ![image-20230104143244243](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20230104143244243.png)

输出的值

![image-20230104143313039](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20230104143313039.png)

这个其实就能理解成实参和形参的样子，方便理解。

### 预定义变量

就是shell设计者事先已经定义好的变量，可以直接在shell脚本中使用

- **$$**         获取当前的进程号 (PID)
- **$!**       后台运行的最后一个进程的进程号(PID)
- **$?**       最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行，如果是非0，那么就表示上个命令执行错误。

### 运算符

- “**$((运算式))**”   或  “**$[运算式]**”  或   **expr m + n**   expr 是 expression的缩写， 用expr 遍历间要用空格，而且作为结果返回要用反引号   “``”。
- expr    乘法   “**\\***”      除法   **/**        取余      **%**
- ![image-20230104151421824](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20230104151421824.png)

输出结果， 第三种方式是最麻烦的 不能直接相加之后再相乘必须要有一个中间变量， 而且还要用反引号， 乘法  还得写成 \\*

![image-20230104151450705](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20230104151450705.png)

### 条件判断

判断语句：

- 字符串比较用   =      相等返回true，  否则返回false
- 两个整数比较
  - **-lt**      小于  little 
  - **-le**     小于等于  little equal
  - **-eq**    等于    equal
  - **-gt**    大于    great
  - **-ge**     大于等于   great equal
  - **-ne**    不等于   no equal
- 按照文件的劝降进行判断
  - **-r**   有读的权限
  - **-w**     有写的权限
  - **-x**     有执行的权限
- 按照文件类型进行判断
  - **-f**       文件存在并且是个常规的文件
  - **-e**    文件存在
  - **-d**     文件存在并是一个目录

基本语法是：

> if [  ]      #  []  中括号的两边要有空格， 没有空格就会报错， 只要非空就 为true，， [ 0 ]    也是返回true
>
> then
>
> ​	echo ""
>
> fi

![image-20230104154815657](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20230104154815657.png)

基本格式就是这样的， 一定要用   **fi**   结束判断语句。

### 流程控制

>if [ 条件判断式 ]
>
>then
>
>​	echo
>
>elif [ 条件判断式 ]
>
>then
>
>​	echo
>
>else
>
>​	echo
>
>fi

如果有多个条件并列成立的话应该是这样的

>f [ 条件判断式 ]
>
>then
>
>​	echo
>
>elif [ 条件判断式 ] && [ 条件判断式 ]
>
>then
>
>​	echo
>
>else
>
>​	echo
>
>fi
>
>

上面的就是多分支的形式

**case语句**

> case $1 in    # 表示获取第一个参数的值
>
> "1")      # 如果第一个参数值是1 ，就执行echo中的值
>
> echo
>
> ;;      #  结束第一个判断
>
> "2")   # 如果第一个参数是2， 就执行echo中的值
>
> echo
>
> ;;     # 结束第二个判断
>
> "3")
>
> echo
>
> ;;
>
> *)   # 表示否则都不满足上面的值，其他
>
> echo "其他"
>
> ;;
>
> esac     #  表示整个case语句结束， 就是case的反过来写

### 循环

> for i in "值1， 值2， ..."
>
> do
>
> ​	echo
>
> done
>
> 打印1到100
>
> for (( i = 1; i <= 100; i ++ ))   #  里面的括号的两边也是要添加空格的
>
> do
>
> ​	echo $i
>
> done

![image-20230104161111738](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20230104161111738.png)



>while 循环
>
>基本语法
>
>while [ 条件判断 ]   # 注意就是中括号的两边要有空格，而且while和中括号之间也是有空格的
>
>do
>
>​	echo
>
>done

![image-20230105132906040](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20230105132906040.png)

while循环就是形如这样的

### 读取控制台输入

基本语法

- read [选项]  变量名
  - -p     指定读取值时的提示符
  - -t      指定读取值时等待的时间，如果没有在指定的时间内输入，就不再等待了

![image-20230105133655808](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20230105133655808.png)

![image-20230105133713223](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20230105133713223.png)

如果还使用了    -t  这个选项，那么就要在指定的时间内输入值， 不然就会跳出这个输入的阶段了，也就是什么都没有。

### 函数

系统函数：

- basename          返回完整路径最后  /  的部分， 常用于获取文件名	

![image-20230105134149256](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20230105134149256.png)

![image-20230105134230046](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20230105134230046.png)

- dirname            返回完整路径最后   /  的前面的部分，  常用于返回路径的部分， 刚好和上面的是反过来的

自定义函数

- > function 函数名() {
  >
  > ​	函数体
  >
  > }
  >
  > 
  >
  > 调用
  >
  > 函数名                     # 就ok了
  >
  > 如果还要传入参数的话， 
  >
  > 函数名 $a1 $a2          #就行了

  ![image-20230105135234315](C:\Users\天若有情天亦老\AppData\Roaming\Typora\typora-user-images\image-20230105135234315.png)

这里的自定义函数有点像js中的函数的写法， 也是用function关键字， 如果学过js的话，应该好理解一点。

# Ubuntu软件操作(apt)

- **sudo apt-get update**      更新源
- **sudo apt-get install package**     安装软件包
- **sudo apt-get remove package**       删除软件包
- **sudo apt-cache show package**     获取包相关的信息， 如说明，大小，版本等
- **sudo apt-get source package**       下载该包的源代码

### 使用dump备份

dump 支持分卷和增量备份 （所谓增量备份是指在上次备份的基础上 备份， 也就是不会再一次把上次备份过的再备份，也就是对上次备份的文件，进行修改，增加，这也叫 差异备份）

- **dump [选项]**
  - **-[0-9]**       表示备份的层级， 0表示完整备份， 1就表示再0的基础上备份了，2也就是再1的基础上备份，以此类推，到9之后又要从0开始备份了
  - **-f**       指定备份文件后的名字
  - **-j**        调用balib库压缩备份文件，  也就是将备份后的文件压缩成   bz2  格式，让文件更小
  - **-T**     指定开始备份的时间于日期
  - **-u**        备份完毕之后，在  /etc/dumpdates中记录备份的文件系统，层级，时间
  - **-t**      指定文件名，   若该文件已存在备份文件中，则列出名称
  - **-W**      显示需要备份的文件及其最后一个备份的层级、时间
  - **-w**        与  -W相似，  但是仅显示需要备份的文件

> 例如 将 /boot分区所有的内容备份到 /opt/book.bak.bz2文件中， 备份层级为0
>
> **dump -0uj -f /opt/boot.bak.bz2 /book**
>
> 这里是-0就表示0层级就是完全备份， -u就表示可以在 /etc/dumpdares中查到， -j就以bz2的格式压缩， 最后面的就是要备份的分区
>
> 如果在/book中添加了一些文件，又要备份， 那么这时就直接把0改成1就行了
>
> 可以使用  **cat /etc/dumpdates**，  查看备份的文件时间

dump备份文件或目录  是不能进行，增量备份的， 只有备份分区的时候才行，

当然这里的备份，也还只是在本机上，如果系统坏了还是没有用的， 所有先在本机上定期备份，然后把这些备份文件上传到另一个服务器上。

### 使用restore完成恢复

使用restore命令 用来恢复已备份的文件，可以从dump生成的备份文件中恢复原文件

- **restore [模式选项] [选项]**

  - **-C**       使用对比模式， 不能混用，在一次命令中，只能指定一种
  - **-i**        使用交互模式，   将备份的文件与已存在的文件相互对比
  - **-r**          进行还原模式       如果有增量备份文件， 就要一次还原， 也就是从0层级依次到9层级还原这样才能把所有文件还原
  - **-t**       查看模式，  看备份文件有哪些

  **-f**         从指定的文件中读取备份数据，进行还原操作

> 比较备份文件和原文件的区别
>
> restore -C -f book.bak.bz2         #   这里的  -f   表示  这个备份文件和当前目录中的文件有什么区别























